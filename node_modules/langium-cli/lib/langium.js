"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = require("commander");
const jsonschema_1 = require("jsonschema");
const generate_1 = require("./generate");
const util_1 = require("./generator/util");
const package_1 = require("./package");
const program = new commander_1.Command();
program
    .version(util_1.cliVersion)
    .command('generate')
    .description('Generate code for a Langium grammar')
    .option('-f, --file <file>', 'the configuration file or package.json setting up the generator')
    .option('-w, --watch', 'enables watch mode', false)
    .action((options) => {
    runGenerator(options).catch(err => {
        console.error(err);
        process.exit(1);
    });
});
program.command('extract-types')
    .argument('<file>', 'the langium grammar file to generate types for')
    .option('-o, --output <file>', 'output file name. Default is types.langium next to the grammar file.')
    .option('-f, --force', 'Force overwrite existing file.')
    .action((file, options) => {
    options.grammar = file;
    (0, generate_1.generateTypes)(options).catch(err => {
        console.error(err);
        process.exit(1);
    });
});
program.parse(process.argv);
async function runGenerator(options) {
    const configs = await (0, package_1.loadConfigs)(options);
    const validation = (0, jsonschema_1.validate)(configs, util_1.schema, {
        nestedErrors: true
    });
    if (!validation.valid) {
        (0, util_1.log)('error', options, chalk_1.default.red('Error: Your Langium configuration is invalid.'));
        const errors = validation.errors.filter(error => error.path.length > 0);
        errors.forEach(error => {
            (0, util_1.log)('error', options, `--> ${error.stack}`);
        });
        process.exit(1);
    }
    const results = await Promise.all(configs.map(config => (0, generate_1.generate)(config, options)));
    const allSuccessful = results.every(result => result.success);
    if (options.watch) {
        printSuccess(results);
        console.log((0, util_1.getTime)() + 'Langium generator will continue running in watch mode.');
        await runWatcher(configs, options, await allGeneratorFiles(results));
    }
    else if (!allSuccessful) {
        process.exit(1);
    }
    else {
        console.log(`Langium generator finished ${chalk_1.default.green.bold('successfully')} in ${(0, util_1.elapsedTime)()}ms`);
    }
}
async function allGeneratorFiles(results) {
    const files = Array.from(new Set(results.flatMap(e => e.files)));
    const filesExist = await Promise.all(files.map(e => fs_extra_1.default.exists(e)));
    return files.filter((_, i) => filesExist[i]);
}
async function runWatcher(configs, options, files) {
    if (files.length === 0) {
        return;
    }
    const watchers = [];
    for (const grammarFile of files) {
        const watcher = fs_extra_1.default.watch(grammarFile, undefined, watch);
        watchers.push(watcher);
    }
    // The watch might be triggered multiple times
    // We only want to execute once
    let watcherTriggered = false;
    async function watch() {
        if (watcherTriggered) {
            return;
        }
        watcherTriggered = true;
        // Delay the generation a bit in case multiple files are changed at once
        await delay(20);
        console.log((0, util_1.getTime)() + 'File change detected. Starting compilation...');
        const results = await Promise.all(configs.map(config => (0, generate_1.generate)(config, options)));
        for (const watcher of watchers) {
            watcher.close();
        }
        printSuccess(results);
        runWatcher(configs, options, await allGeneratorFiles(results));
    }
}
function printSuccess(results) {
    if (results.every(result => result.success)) {
        console.log(`${(0, util_1.getTime)()}Langium generator finished ${chalk_1.default.green.bold('successfully')} in ${(0, util_1.elapsedTime)()}ms`);
    }
}
async function delay(ms) {
    return new Promise(resolve => {
        setTimeout(() => resolve(), ms);
    });
}
//# sourceMappingURL=langium.js.map