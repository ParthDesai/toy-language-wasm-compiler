"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.propertyTypeToString = exports.isTypeAssignable = exports.TypeResolutionError = exports.InterfaceType = exports.UnionType = exports.isInterfaceType = exports.isUnionType = exports.isStringType = exports.isPrimitiveType = exports.isValueType = exports.flattenPropertyUnion = exports.isPropertyUnion = exports.isArrayType = exports.isReferenceType = void 0;
const generator_node_1 = require("../../../generator/generator-node");
const types_util_1 = require("../types-util");
function isReferenceType(propertyType) {
    return 'referenceType' in propertyType;
}
exports.isReferenceType = isReferenceType;
function isArrayType(propertyType) {
    return 'elementType' in propertyType;
}
exports.isArrayType = isArrayType;
function isPropertyUnion(propertyType) {
    return 'types' in propertyType;
}
exports.isPropertyUnion = isPropertyUnion;
function flattenPropertyUnion(propertyType) {
    if (isPropertyUnion(propertyType)) {
        const items = [];
        for (const type of propertyType.types) {
            items.push(...flattenPropertyUnion(type));
        }
        return items;
    }
    else {
        return [propertyType];
    }
}
exports.flattenPropertyUnion = flattenPropertyUnion;
function isValueType(propertyType) {
    return 'value' in propertyType;
}
exports.isValueType = isValueType;
function isPrimitiveType(propertyType) {
    return 'primitive' in propertyType;
}
exports.isPrimitiveType = isPrimitiveType;
function isStringType(propertyType) {
    return 'string' in propertyType;
}
exports.isStringType = isStringType;
function isUnionType(type) {
    return type && 'type' in type;
}
exports.isUnionType = isUnionType;
function isInterfaceType(type) {
    return type && 'properties' in type;
}
exports.isInterfaceType = isInterfaceType;
class UnionType {
    constructor(name, options) {
        var _a, _b;
        this.superTypes = new Set();
        this.subTypes = new Set();
        this.containerTypes = new Set();
        this.typeNames = new Set();
        this.name = name;
        this.reflection = (_a = options === null || options === void 0 ? void 0 : options.reflection) !== null && _a !== void 0 ? _a : false;
        this.declared = (_b = options === null || options === void 0 ? void 0 : options.declared) !== null && _b !== void 0 ? _b : false;
    }
    toAstTypesString(reflectionInfo) {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`export type ${this.name} = ${propertyTypeToString(this.type, 'AstType')};`, generator_node_1.NL);
        if (this.reflection && reflectionInfo) {
            unionNode.append(generator_node_1.NL);
            pushReflectionInfo(unionNode, this.name);
        }
        return (0, generator_node_1.toString)(unionNode);
    }
    toDeclaredTypesString(reservedWords) {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`type ${escapeReservedWords(this.name, reservedWords)} = ${propertyTypeToString(this.type, 'DeclaredType')};`, generator_node_1.NL);
        return (0, generator_node_1.toString)(unionNode);
    }
}
exports.UnionType = UnionType;
class InterfaceType {
    get superProperties() {
        const map = new Map();
        for (const property of this.properties) {
            map.set(property.name, property);
        }
        for (const superType of this.interfaceSuperTypes) {
            const allSuperProperties = superType.superProperties;
            for (const superProp of allSuperProperties) {
                if (!map.has(superProp.name)) {
                    map.set(superProp.name, superProp);
                }
            }
        }
        return Array.from(map.values());
    }
    get allProperties() {
        const map = new Map(this.superProperties.map(e => [e.name, e]));
        for (const subType of this.subTypes) {
            this.getSubTypeProperties(subType, map);
        }
        const superProps = Array.from(map.values());
        return superProps;
    }
    getSubTypeProperties(type, map) {
        const props = isInterfaceType(type) ? type.properties : [];
        for (const prop of props) {
            if (!map.has(prop.name)) {
                map.set(prop.name, prop);
            }
        }
        for (const subType of type.subTypes) {
            this.getSubTypeProperties(subType, map);
        }
    }
    get interfaceSuperTypes() {
        return Array.from(this.superTypes).filter((e) => e instanceof InterfaceType);
    }
    constructor(name, declared, abstract) {
        this.superTypes = new Set();
        this.subTypes = new Set();
        this.containerTypes = new Set();
        this.typeNames = new Set();
        this.declared = false;
        this.abstract = false;
        this.properties = [];
        this.name = name;
        this.declared = declared;
        this.abstract = abstract;
    }
    toAstTypesString(reflectionInfo) {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const interfaceSuperTypes = this.interfaceSuperTypes.map(e => e.name);
        const superTypes = interfaceSuperTypes.length > 0 ? (0, types_util_1.distinctAndSorted)([...interfaceSuperTypes]) : ['AstNode'];
        interfaceNode.append(`export interface ${this.name} extends ${superTypes.join(', ')} {`, generator_node_1.NL);
        interfaceNode.indent(body => {
            if (this.containerTypes.size > 0) {
                body.append(`readonly $container: ${(0, types_util_1.distinctAndSorted)([...this.containerTypes].map(e => e.name)).join(' | ')};`, generator_node_1.NL);
            }
            if (this.typeNames.size > 0) {
                body.append(`readonly $type: ${(0, types_util_1.distinctAndSorted)([...this.typeNames]).map(e => `'${e}'`).join(' | ')};`, generator_node_1.NL);
            }
            pushProperties(body, this.properties, 'AstType');
        });
        interfaceNode.append('}', generator_node_1.NL);
        if (reflectionInfo) {
            interfaceNode.append(generator_node_1.NL);
            pushReflectionInfo(interfaceNode, this.name);
        }
        return (0, generator_node_1.toString)(interfaceNode);
    }
    toDeclaredTypesString(reservedWords) {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const name = escapeReservedWords(this.name, reservedWords);
        const superTypes = (0, types_util_1.distinctAndSorted)(this.interfaceSuperTypes.map(e => e.name)).join(', ');
        interfaceNode.append(`interface ${name}${superTypes.length > 0 ? ` extends ${superTypes}` : ''} {`, generator_node_1.NL);
        interfaceNode.indent(body => pushProperties(body, this.properties, 'DeclaredType', reservedWords));
        interfaceNode.append('}', generator_node_1.NL);
        return (0, generator_node_1.toString)(interfaceNode);
    }
}
exports.InterfaceType = InterfaceType;
class TypeResolutionError extends Error {
    constructor(message, target) {
        super(message);
        this.name = 'TypeResolutionError';
        this.target = target;
    }
}
exports.TypeResolutionError = TypeResolutionError;
function isTypeAssignable(from, to) {
    if (isPropertyUnion(from)) {
        return from.types.every(fromType => isTypeAssignable(fromType, to));
    }
    else if (isPropertyUnion(to)) {
        return to.types.some(toType => isTypeAssignable(from, toType));
    }
    else if (isReferenceType(from)) {
        return isReferenceType(to) && isTypeAssignable(from.referenceType, to.referenceType);
    }
    else if (isArrayType(from)) {
        return isArrayType(to) && isTypeAssignable(from.elementType, to.elementType);
    }
    else if (isValueType(from)) {
        if (isUnionType(from.value)) {
            if (isValueType(to) && to.value.name === from.value.name) {
                return true;
            }
            return isTypeAssignable(from.value.type, to);
        }
        if (!isValueType(to)) {
            return false;
        }
        if (isUnionType(to.value)) {
            return isTypeAssignable(from, to.value.type);
        }
        else {
            return isInterfaceAssignable(from.value, to.value, new Set());
        }
    }
    else if (isPrimitiveType(from)) {
        return isPrimitiveType(to) && from.primitive === to.primitive;
    }
    else if (isStringType(from)) {
        return (isPrimitiveType(to) && to.primitive === 'string') || (isStringType(to) && to.string === from.string);
    }
    return false;
}
exports.isTypeAssignable = isTypeAssignable;
function isInterfaceAssignable(from, to, visited) {
    if (visited.has(from.name)) {
        return true;
    }
    visited.add(from.name);
    if (from.name === to.name) {
        return true;
    }
    for (const superType of from.superTypes) {
        if (isInterfaceType(superType) && isInterfaceAssignable(superType, to, visited)) {
            return true;
        }
    }
    return false;
}
function propertyTypeToString(type, mode = 'AstType') {
    if (isReferenceType(type)) {
        const refType = propertyTypeToString(type.referenceType, mode);
        return mode === 'AstType' ? `Reference<${refType}>` : `@${typeParenthesis(type.referenceType, refType)}`;
    }
    else if (isArrayType(type)) {
        const arrayType = propertyTypeToString(type.elementType, mode);
        return mode === 'AstType' ? `Array<${arrayType}>` : `${typeParenthesis(type.elementType, arrayType)}[]`;
    }
    else if (isPropertyUnion(type)) {
        const types = type.types.map(e => typeParenthesis(e, propertyTypeToString(e, mode)));
        return (0, types_util_1.distinctAndSorted)(types).join(' | ');
    }
    else if (isValueType(type)) {
        return type.value.name;
    }
    else if (isPrimitiveType(type)) {
        return type.primitive;
    }
    else if (isStringType(type)) {
        return `'${type.string}'`;
    }
    throw new Error('Invalid type');
}
exports.propertyTypeToString = propertyTypeToString;
function typeParenthesis(type, name) {
    const needsParenthesis = isPropertyUnion(type);
    if (needsParenthesis) {
        name = `(${name})`;
    }
    return name;
}
function pushProperties(node, properties, mode, reserved = new Set()) {
    function propertyToString(property) {
        const name = mode === 'AstType' ? property.name : escapeReservedWords(property.name, reserved);
        const optional = property.optional && !isMandatoryPropertyType(property.type);
        const propType = propertyTypeToString(property.type, mode);
        return `${name}${optional ? '?' : ''}: ${propType}`;
    }
    (0, types_util_1.distinctAndSorted)(properties, (a, b) => a.name.localeCompare(b.name))
        .forEach(property => node.append(propertyToString(property), generator_node_1.NL));
}
function isMandatoryPropertyType(propertyType) {
    if (isArrayType(propertyType)) {
        return true;
    }
    else if (isReferenceType(propertyType)) {
        return false;
    }
    else if (isPropertyUnion(propertyType)) {
        return propertyType.types.every(e => isMandatoryPropertyType(e));
    }
    else if (isPrimitiveType(propertyType)) {
        const value = propertyType.primitive;
        return value === 'boolean';
    }
    else {
        return false;
    }
}
function pushReflectionInfo(node, name) {
    node.append(`export const ${name} = '${name}';`, generator_node_1.NL);
    node.append(generator_node_1.NL);
    node.append(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
    node.indent(body => body.append(`return reflection.isInstance(item, ${name});`, generator_node_1.NL));
    node.append('}', generator_node_1.NL);
}
function escapeReservedWords(name, reserved) {
    return reserved.has(name) ? `^${name}` : name;
}
//# sourceMappingURL=types.js.map