"use strict";
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSDocDocumentationProvider = void 0;
const syntax_tree_1 = require("../syntax-tree");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const jsdoc_1 = require("./jsdoc");
class JSDocDocumentationProvider {
    constructor(services) {
        this.indexManager = services.shared.workspace.IndexManager;
        this.grammarConfig = services.parser.GrammarConfig;
    }
    getDocumentation(node) {
        const lastNode = (0, cst_util_1.findCommentNode)(node.$cstNode, this.grammarConfig.multilineCommentRules);
        if ((0, syntax_tree_1.isLeafCstNode)(lastNode) && (0, jsdoc_1.isJSDoc)(lastNode)) {
            const parsedJSDoc = (0, jsdoc_1.parseJSDoc)(lastNode);
            return parsedJSDoc.toMarkdown({
                renderLink: (link, display) => {
                    return this.documentationLinkRenderer(node, link, display);
                }
            });
        }
        return undefined;
    }
    documentationLinkRenderer(node, name, display) {
        var _a;
        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);
        if (description && description.nameSegment) {
            const line = description.nameSegment.range.start.line + 1;
            const character = description.nameSegment.range.start.character + 1;
            const uri = description.documentUri.with({ fragment: `L${line},${character}` });
            return `[${display}](${uri.toString()})`;
        }
        else {
            return undefined;
        }
    }
    findNameInPrecomputedScopes(node, name) {
        const document = (0, ast_util_1.getDocument)(node);
        const precomputed = document.precomputedScopes;
        if (!precomputed) {
            return undefined;
        }
        let currentNode = node;
        do {
            const allDescriptions = precomputed.get(currentNode);
            const description = allDescriptions.find(e => e.name === name);
            if (description) {
                return description;
            }
            currentNode = currentNode.$container;
        } while (currentNode);
        return undefined;
    }
    findNameInGlobalScope(node, name) {
        const description = this.indexManager.allElements().find(e => e.name === name);
        return description;
    }
}
exports.JSDocDocumentationProvider = JSDocDocumentationProvider;
//# sourceMappingURL=documentation-provider.js.map